
\iffalse \bibliography{../bibliography.bib} \fi

\chapter{Background}

\editor{Need references and citations in this chapter}

\editor{Needs introduction paragraph here.}

\section{Level of Detail}

There are several limitations when it comes to rendering large scenes.
In general, the large amount of geometry required to represent these scenes is at odds with the limited resources of the computer.
The GPU is only able to render and shade a certain amount of geometry due to processor speed and number of available processors.
Scene geometry must be loaded into main memory, then transferred to graphics memory, both of which have throughput maximums and storage maximums.
The hardware interface also has some CPU overhead with regard to submitting draw commands, so we are limited in the number of draw calls we can make.

As such, in order to render large scenes with a large number of scene elements, we need to account of level of detail.
`Detail' in this context refers generally to the amount of geometry used to represent a scene element.
Consider, for example, a tree.
\editor{Figure of different tree representations here}
A high-detail representation of a tree would consist of geometry to represent branches, individual leaves, and the shape of the trunk.
A low-detail representation of a tree might simply consist of a trunk-colored box and a leaf-colored cone.
Smaller details like branches and individual leaves are no longer visible in the low-detail representation, but are represented more abstractly.
The advantage of the low-detail representation is that it requires fewer resources to draw.

In addition, it is also a bad idea to render distant scene elements at full-detail even if resources are available.
The farther away a scene element is from the viewpoint, the smaller it is in terms of screen-space.
Drawing primitives that are smaller in terms of screen-space can cause aliasing, a visual artifact.
As such, low-detail representations can sometimes appear better than their high-detail counterparts at large view distances.

Level-of-detail is commonly abbreviated LOD.
A rendering system that is capable of representing scene elements in both high-detail and low-detail formats is referred to as a LOD rendering system.
A LOD system must switch freely between these representations as the viewpoint changes to reduce the amount of geometry and draw calls required to render a large scene, while still representing nearby objects at full detail.

One common LOD system is texture mipmapping. \cite{opengl_mipmaps}


\section{Terrain Rendering}

Terrain rendering is a prime candidate for using a level-of-detail algorithm because terrain consists of a large amount of geometry and is visible both up close and at large view distances.
Over the years there have been many published techniques for terrain rendering.
\cite{p-bdam}
\cite{hardware_lod}
\cite{diamondterrain}
\cite{roambetter}
\cite{clod}
\cite{roam}
\cite{righttri}
However, we will focus on some more modern techniques that serve as the basis for the terrain system presented in this paper.


\subsection{Heightmaps}

A common technique for simplifying terrain representation is the use of a heightmap.
A heightmap is based on the assumption that terrain elevation is uniformly sampled, i.e. we know the height of the terrain at evenly spaced intervals.
Instead of storing a set of 3D points to represent the terrain surface, we can instead create a generic 2D regular grid and store the height separately.
This separate array of height values is referred to as a heightmap.


\subsection{Geometry Clipmaps}

Geometry clipmaps is a terrain rendering technique from 2004 that uses a series of nested regular grids to represent each detail level of the terrain. \cite{geometry_clipmaps}
A regular grid of terrain at maximum detail is centered around the viewpoint.
Another regular grid of terrain at twice the scale (and thus half resolution) is centered around that inner grid, but with a hole cut out where the inner grid is located.
Thus the second grid is clipped by the first grid (i.e. a clipmap).
Each of these grids is referred to as a layer.
The geometry clipmaps approach also includes a system for blending the low and high detail representations at layer boundaries, and for updating the heightmaps used by each layer.
Heightmaps are updated toroidally so that small incremental updates are possible as the viewpoint moves.
\editor{Toroidal update figure}

More recently, work has been done on improving the geometry clipmaps technique for use with modern rendering hardware, but the principles remain the same. \cite{gems_clipmaps}

\section{Terrain Generation}

However, before addressing the problem of how to render terrain we must first decide where our terrain data will come from.

There are many possible sources of terrain data.
Acquired data from the real world is often available.
The USGS provides satellite data for much of the world's surface.
Some game engines also use terrain editing tools that allow artists to sculpt terrain manually.

However, it is also possible to implement algorithms that procedurally construct terrain.
The advantage of using procedurally generated terrain is that it requires less time/effort intensive than artistically creating a terrain, and it does not require much or any disk space (as opposed to using acquired data which can be very large).

Procedural terrain generation methodologies usually employ one or more of the follow techniques.

\begin{itemize}
\item Physical process simulations
\item Fractal processes
\item Noise algorithms
\end{itemize}

\subsection{Physical process simulations}

Real terrain is shaped by erosion, the gradual shaping of landscape caused by water, wind, and other forces.
Some terrain generation techniques simulate these physical processes on a starter dataset to create realistic surfaces. \cite{hydrology}

However, the nature of the physical simulation usually requires the entire world (or at least individual continents) to be generated at once.
In other words, the generation process itself cannot easily support level-of-detail.


\subsection{Fractal processes}

Another technique for generating terrain is a fractal process, some algorithm that operates on geometry to add detail and which can be re-applied at smaller and smaller scale until a highly detailed surface results.
The most common form of fractal process is the Diamond-square Algorithm which sequentially subdivides and modulates a regular grid.


\subsection{Noise Algorithms}

Noise algorithms are similar to fractal processes but more heavily based in mathematics.
The most typical way that noise algorithms are used is by generating a patch or formula for noise (typically in 2 dimensions, though sometimes more) and employing a technique called fractional Brownian motion to create a heightmap.
Noise is generally a signal that varies randomly.
Coherent noise is a special brand of noise that is more useful for generation purposes.
As a random signal, it is reasonable to expect that a large change in domain results in a random change in output for a given noise function.
Coherent noise has the property that for small changes in domain, only a small change in output will result.


\subsubsection{Coherent Noise}

There are two major types of coherent noise.

% \subsubsection{Value noise}

The most simple is value noise.
Value noise is generated by calculating random numbers at fixed intervals and interpolating between the values.

% Value noise works by using a pseudo-random number generator to generate a set of initial random values, then interpolate between those values.

% \subsubsection{Gradient noise}

Another type of coherent noise is gradient noise.
Gradient noise is generated by calculating vectors at a fixed interval, then performing a dot product to calculate intermediary values instead of interpolating.
It is a numerically similar process to value noise, but produces noise with more variance - that is, more detail in higher frequencies.

% Gradient noise is a modification of value noise where gradient vectors are calculated at grid points, and noise is generated by calculating the dot product between a gradient vector and the offset to the calculated location.
% The purpose of this technique is the improve the mathematical properties of the

\subsubsection{Fractional Brownian Motion}

Fractional Brownian motion is a technique for taking a noise function and adding detail at higher frequencies.
The general approach is:
\begin{enumerate}
\item Take a noise function as input
\item Double the frequency and halve the amplitude of the noise function, then add it to itself. This is called the second octave.
\item Double again the frequency and halve again the amplitude of the noise function, then add this too into the sum. This is the third octave.
\item Repeat Step 3 for subsequent octaves until amplitude is close enough to zero that added octaves produce no change in the output, or until desired amount of detail is reached.
\end{enumerate}

In general you do not need to exactly double the frequency or halve the amplitude each octave, but can fine tune these values e.g. by multiplying the frequency by 1.2 and the amplitude by 0.3.

\subsubsection{Ridged Multifractal}

An additional step can be added before summing each individual octave.
By first taking the negated absolute value of each generated noise value, a ridged version of fractional brownian motion can be created.
This technique is commonly referred to as Ridged multifractal, or RMf.

\subsubsection{Noise Distortion}

Ridged multifractal works on fractal brownian motion by modifying the range of each noise function, but it is also possible to modify the domain in a similar fashion.
Using two additional FBM generators, an offset vector can be produced for each sample of the height generator.
This technique helps break up the homogeneous appearance of generated terrain by shrinking and expanding different areas.


\section{Voxels}


\section{Screen-space Ambient Occlusion}

\subsection{Ambient Occlusion}

\subsection{Screen-space}

\subsection{HBAO+}

